package neurons

/*

1 правило - все отношения тел это обмен зарядом, от более заряженного к менее

2 правило - сам заряд не передаёться ,а лишь служит направляющим, для создания нейромедиаторных связей.
			заряженное тело(нейрон или группа нейронов) это маяк, 
			на который поляризирует другое заряженно тело с отличающимся зарядом

3 правило - все нейроны активируються с одной силой но разными частотами
4 правило - нейроны с одинаковой частотой могут группироваться
5 правило - нейроны имеют типизацию, по векторным возможностям

6 правило - нейрон может иметь несколько паттернов на которые реагирует
7 правило - нейрон имеет на каждый вход нейропластичность(плавающий уровень чувствительности)
8 правило - нейрон имеет привыкание - временно понижаеться нейропластичность до полной не чувствительности
9 правило - каждый нейрон что активировался получает немного удовольствия 
9 правило - группа нейронов затухает не мгновенно и уровень его частоты падает постепенно
			это следствие закольцованности связей, помогает для появления памяти - связывания событий во времени

10 правило - активация одного нейрона происходит благодаря синхронизированной стимуляции множества других

			(каждый нейрон имеет свою зону, чем выше частота соседа(тем эффективнее может строить путь в нужную сторону), 
				тем дальше он зайдет на территорию слабого, место где столкнуться будет местом синхронизации 
				и выходом на следующий уровень)

			Нейрон продвигает свою активность передавая всем в нужном ему фокусе, это выглядит как волна 
			Это продолжаеться пока не наступит локальная синхронизация
			Нейрон представитель такой синхронизации имеет фокус вверх в определённом радиусе
			Каждый уровень - это определённый уровень абстракции чем выше тем более абстрактым будет
*/

import (
	"github.com/g3n/engine/math32"
)

// v, ok := m["Answer"] //проверка на наличие ключа в карте
// fmt.Println("The value:", v, "Present?", ok)

type neuron struct{
	coord math32.Vector3 			// местоположение в пространстве
	coordStimulus []math32.Vector3  // список координат тех кто способствовал активаци в момент времени - для отрисовки связей
	specVector int8				    // специализация вектора в каком направлении отдаёт медиатор (полный радиус или только вверх, или в лево...)
	radius int8 					// максимальная радиус-дистанция куда передаст медиатор, всем кто попал в этот радиус будет передан медиатор

	dendrite []int8                 // массив где индекс означает сторону с которой пришёл заряд, а значение его частоту активаций
	Neuroplasticity []int8          // массив где индекс означает сторону - значение хранит нейропластичность для каждого направления

	/*
		 мапа хранит в ключе строковое представление сформированного нейромедиатора, 
		 а значением будет частота повторений этого нейромедиатора,

		 нейропластичность будет расчитываться от частоты и силы, так же и специализация
	*/
	dendrMapTemp []int8 

	/*
		список наборов нейромедиаторов - специализация, реагирует только на такую комбинацию
		может иметь несколько наборов

		в набор должно входить сторона и нейромедиатор того кто посылает
	*/
	dendrSpec []int8
	

	/*
	мапа что хранит в себе всех соседей в заданном радиусе и векторном направлении и 
	которым будет раздавать свой нейромедиатор
	*/
	axonMap []int8
}

/*
dotGeom := geometry.NewCircle(0, 3)
dotMat := material.NewPhong(math32.NewColor("White"))
dotMesh := graphic.NewPoints(dotGeom, dotMat)
dotMesh.SetPosition(
	float32(rand.Int31n(20)),
	float32(rand.Int31n(20)),
	float32(rand.Int31n(20)))
app.Scene().Add(dotMesh)
*/
func(n *neuron) NewNeuron() *neuron{
	return &neuron{
		coord: *math32.NewVector3(0, 0, 0),
	}
}

func(n *neuron) SetPosition(x, y, z float32){
	n.coord.X = x
	n.coord.Y = y
	n.coord.Z = z
}